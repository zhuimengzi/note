ECMAScript：一种通用的跨平台编程语言

历史简介

该ECMA标准基于几种始发技术，最着名的是JavaScript™（NetscapeCommunications）和JScript™（Microsoft Corporation）。 本标准的制定始于1996年11月。
ECMA标准提交给ISO / IEC JTC 1，以通过快速通道程序。该ECMA标准已由1997年6月的ECMA大会通过。

目录

1范围1
2一致性1
3参考文献1
4概述1
4.1 Web脚本2
4.2语言概述2
4.2.1对象2
4.3定义3
4.3.1类型3
4.3.2原始值3
4.3.3对象3
4.3.4构造函数4
4.3.5原型4
4.3.6原生对象4
4.3.7内置对象4
4.3.8主机对象4
4.3.9未定义4
4.3.10未定义类型4
4.3.11 Null 4
4.3.12空型4
4.3.13布尔值4
4.3.14布尔类型4
4.3.15布尔对象4
4.3.16字符串值4
4.3.17字符串类型5
4.3.18字符串对象5
4.3.19数值5
4.3.20数字类型5
4.3.21号码对象5
4.3.22无限5
4.3.23 NaN 5
5符号公约5
5.1语法和词汇语法5
5.1.1无上下文语法5
5.1.2词汇语法5
5.1.3数字字符串语法6
5.1.4句法语法6
5.1.5语法符号6
5.2算法约定8
6来源文本9
7词汇约定9
7.1白色空间9
7.2线路终端机10

- ii - 
  7.3评论10
  7.4令牌11
  7.4.1保留字11
  7.4.2关键词11
  7.4.3未来保留字11
  7.5标识符11
  7.6标点符号12
  7.7文字12
  7.7.1零文字12
  7.7.2布尔文字12
  7.7.3数字文字1​​3
  7.7.4字符串文字15
  7.8自动分号插入17
  7.8.1自动分号插入规则17
  7.8.2自动分号插入示例18
  8种类型19
  8.1未定义类型19
  8.2空型19
  8.3布尔类型19
  8.4字符串类型20
  8.5数字类型20
  8.6对象类型21
  8.6.1属性属性21
  8.6.2内部属性和方法21
  8.7参考类型24
  8.7.1 GetBase（V）24
  8.7.2 GetPropertyName（V）24
  8.7.3 GetValue（V）24
  8.7.4 PutValue（V，W）24
  8.8列表类型25
  8.9完成类型25
  9类型转换25
  9.1至少25
  9.2 ToBoolean 26
  9.3至26号
  9.3.1应用于字符串类型的数字27
  9.4 ToInteger 29
  9.5 ToInt32 :(有符号32位整数）29
  9.6 ToUint32 :(无符号32位整数）30
  9.7 ToUint16 :(无符号16位整数）30
  9.8 ToString 30
  9.8.1 ToString应用于数字类型31
  9.9 ToObject 32
  10执行上下文32
  10.1定义32
  10.1.1功能对象32
  10.1.2可执行代码的类型32
  10.1.3变量实例化33
- iii - 
  10.1.4范围链和标识符决议33
  10.1.5全局对象34
  10.1.6激活对象34
  10.1.7这34
  10.1.8参数对象34
  10.2进入执行环境35
  10.2.1全球代码35
  10.2.2评估代码35
  10.2.3功能和匿名代码35
  10.2.4实施提供的代码35
  11表达式36
  11.1主要表达36
  11.1.1这个关键词36
  11.1.2标识符参考36
  11.1.3字面引用36
  11.1.4分组运营商36
  11.2左手边表达36
  11.2.1属性访问器37
  11.2.2新运营商37
  11.2.3功能调用38
  11.2.4参数列表38
  11.3 Postfix表达式38
  11.3.1后缀增量运算符38
  11.3.2 Postfix递减算子39
  11.4一元操作员39
  11.4.1删除操作符39
  11.4.2 void运算符39
  11.4.3操作员的类型39
  11.4.4前缀增量运算符40
  11.4.5前缀递减运算符40
  11.4.6一元+操作员40
  11.4.7一般操作员40
  11.4.8按位NOT运算符（〜）41
  11.4.9逻辑NOT运算符（！）41
  11.5乘数运算符41
  11.5.1应用*操作符41
  11.5.2应用/操作员42
  11.5.3应用％操作符42
  11.6添加剂操作员43
  11.6.1加法运算符（+）43
  11.6.2减法运算符（ - ）43
  11.6.3将加法运算符（+， - ）应用于数字43
  11.7按位移位操作符44
  11.7.1左移操作符（<<）44
  11.7.2签名的右移操作符（>>）44
  11.7.3无符号右移操作符（>>>）45
  11.8关系运营商45
  11.8.1小于运算符（<）45
  11.8.2大于运算符（>）45
  11.8.3小于或等于运算符（<=）45
- iv - 
  11.8.4大于或等于运算符（> =）46
  11.8.5抽象关系比较算法46
  11.9平等机构46
  11.9.1 equals运算符（==）47
  11.9.2不等于运算符（！=）47
  11.9.3抽象等价比较算法47
  11.10二进制按位运算符48
  11.11二进制逻辑运算符48
  11.12条件运算符（？：）49
  11.13作业人员49
  11.13.1简单作业（=）50
  11.13.2化合物分配（op =）50
  11.14逗号运算符（，）50
  12声明50
  12.1块50
  12.2变量表51
  12.3空语句52
  12.4表达式语句52
  12.5 IF声明52
  12.6迭代语句53
  12.6.1 while声明53
  12.6.2声明53
  12.6.3声明54
  12.7 CONTINUE语句55
  12.8 BREAK声明55
  12.9 RETURN语句55
  12.10 WITH语句56
  13功能定义56
  14计划5715本地ECMAScript对象57
  15.1全局对象58
  15.1.1全局对象的值属性58
  15.1.2全局对象的功能属性58
  15.1.3全局对象的构造函数属性61
  15.1.4全局对象的其他属性61
  15.2对象对象61
  15.2.1对象构造函数被称为函数61
  15.2.2对象构造函数62
  15.2.3对象构造器的属性62
  15.2.4对象原型对象的属性62
  15.2.5对象实例的属性63
  15.3功能对象63
  函数构造函数被称为函数
  15.3.2函数构造函数63
  15.3.3函数构造函数的属性64
  15.3.4函数原型对象的属性64
  15.3.5功能实例的属性64
  - v - 
    15.4数组对象65
    15.4.1被称为函数的数组构造函数65
    15.4.2数组构造函数65
    15.4.3数组构造函数的属性66
    15.4.4阵列原型对象的属性66
    15.4.5阵列实例的属性68
    15.5字符串对象69
    15.5.1被称为函数的String构造函数69
    15.5.2字符串构造函数69
    15.5.3字符串构造函数的属性69
    15.5.4字符串原型对象的属性70
    15.5.5字符串实例的属性73
    15.6布尔对象73
    15.6.1被称为函数的布尔构造函数73
    15.6.2布尔构造函数73
    15.6.3布尔构造函数的属性74
    15.6.4布尔原型对象的属性74
    15.6.5布尔实例的属性74
    15.7数字对象74
    15.7.1被称为函数的数构造函数74
    15.7.2数字构造函数75
    15.7.3数字构造函数的属性75
    15.7.4数字原型对象的属性75
    15.7.5号码实例的属性76
    15.8数学对象76
    15.8.1数学对象的值属性76
    15.8.2数学对象的函数属性77
    15.9日期对象81
    15.9.1内部操作员的日期对象和定义概述81
    15.9.2被称为函数的日期构造函数85
    15.9.3日期构造函数85
    15.9.4日期构造器的属性87
    15.9.5日期原型对象的属性89
    15.9.6日期实例的属性95
    16错误95

1 范围
本标准定义了ECMAScript脚本语言。

2 一致性
ECMAScript的一致性实现必须提供和支持本规范中描述的所有类型，值，对象，属性，函数和程序语法。 ECMAScript的一致性实现被允许提供超出本细节描述的其他类型，值，对象，属性和功能。特别地，ECMAScript的一致性实现被允许提供本说明书中未描述的属性，以及用于这些属性的值，用于本说明书中描述的对象。允许符合ECMAScript的实现来支持本规范中未描述的程序语法。特别地，允许使用ECMAScript的一致的实现来支持使用本说明书第0节中列出的“未来保留字”的程序语法。允许ECMAScript的实现提供本说明书中未描述的属性，并且值这些属性，用于本规范中描述的对象。允许符合ECMAScript的实现来支持本规范中未描述的程序语法。特别地，ECMAScript的一致性实现被允许支持使用本规范第0节中列出的“未来保留字”的程序语法。

3参考文献
ANSI X3.159-1989：美国国家标准信息系统 - 编程语言C，美国国家标准协会（1989）。 ANSI / IEEE Std 1754-1985：用于二进制浮点运算的IEEE标准。纽约电气与电子工程师协会（1985）。 Berners-Lee，T.，Masinter，L.和McCahill，M. Uniform Resource Locators。 RFC 1738，Network Working Group，1994年12月。Gay，David M.正确的二进制十进制和十进制二进制转换。数值分析手册90-10。 AT＆T贝尔实验室（Murray Hill，新泽西州）。 1990年11月30日。可用http：//cm.bell- labs.com/cm/cs/doc/90/4-10.ps.gz。相关代码可用作http：//cm.bell- labs.com/netlib/fp/dtoa.c.gz和http://cm.bell-labs.com/netlib/fp/g_fmt.c.gz，可能也可以在各种netlibmirror站点找到。戈斯林，詹姆斯，比尔·乔伊和Guy Steele。 Java语言规范。 Addison Wesley Publishing Company 1996. Ungar，David和Smith，Randall B. Self：简单的力量。 OOPSLA'87 Conference Proceedings，pp.227-241，Orlando，FL，October，1987. Unicode Consortium。 Unicode标准2.0版。 Addison-Wesley，Reading，Massachusetts（1996）。

4概述
EMCAScript是一种面向对象的编程语言，用于在主机环境中执行计算和操纵计算对象。这里定义的ECMAScript不是计算自给自足的;实际上，在本说明书中没有规定外部数据的输入或计算结果的输出。相反，预期ECMAScript程序的计算环境不仅将提供本说明书中描述的对象和其他设施，还将提供特定的环境特定主机对象，其描述和行为超出了本规范的范围，除了指出它们可以提供可以访问的某些属性以及可以从ECMAScript程序调用的某些功能。脚本语言是一种用于操纵，定制和自动化现有系统的设施的编程语言。在这样的系统中，通过用户界面已经可以使用有用的功能，并且脚本语言是将该功能暴露给程序控制的机制。以这种方式，现有的系统被称为提供完成脚本语言能力的对象和设施的主机环境。一种脚本语言是由专业和非专业程序员使用的，因此可能会有一些非正式语言和内置的语言。 ECMAScript最初设计为Web脚本语言，提供了一种在浏览器中激活Web页面的机制，并将其作为基于Web的客户端 - 服务器架构的一部分执行服务器计算。 ECMAScript可以为各种主机环境提供核心脚本功能，因此除了任何特定的主机环境外，本文档还规定了核心脚本语言。

4.1 Web脚本
Web浏览器为客户端计算提供ECMAScript主机环境，包括例如表示窗口，菜单，弹出窗口，对话框，文本区域，锚点，框架，历史记录，Cookie和输入/输出的对象。此外，主机环境提供了将脚本代码附加到诸如焦点改变，页面和图像加载，卸载，错误和中止，选择，表单提交和鼠标动作等事件的手段。脚本代码出现在HTML中，显示的页面是用户界面元素和固定和计算的文本和图像的组合。脚本代码对用户交互无反应，不需要主程序。 Web服务器为服务器端计算提供不同的主机环境，包括表示请求，客户端和文件的对象，以及锁定和共享数据的机制。通过一起使用浏览器端和服务器端脚本，可以在客户端和服务器之间分配计算，同时为基于Web的应用程序提供定制的用户界面。支持ECMAScript的每个Web浏览器和服务器都提供自己的主机环境，完成ECMAScript执行环境。

4.2语言概述
以下是ECMAScript的非正式概述 - 不是描述所有的语言部分。这个概述不是标准的一部分。 ECMAScript是基于对象的：基本语言和主机设施由对象提供，ECMAScript程序是一组通信对象。 ECMAScript对象是一个无序的属性集合，每个属性都有0个或更多个属性，它们决定了每个属性的使用方式 - 例如，当属性的ReadOnly属性设置为true时，执行的ECMAScript代码尝试更改该物业没有任何影响。属性是容纳其他对象，原始值或方法的容器。原始值是以下内置类型之一的成员：Undefined，Null，Boolean，Number和String;一个对象是剩下的内置类型Object的一个成员;并且方法是通过属性与对象相关联的函数。 ECMAScript定义了一个内置对象的集合，其中包含ECMAScript实体的定义。这些内置对象包括全局对象，Object对象，Function对象，Array对象，String对象，Boolean对象，Number对象，Math对象和Date对象。 ECMAScript还定义了一组内置的运算符，严格来说可能不是函数或方法。 ECMAScript运算符包括各种一元运算，乘法运算符，加法运算符，按位移位运算符，关系运算符，等式运算符，二进制运算符，二进制逻辑运算符，赋值运算符和逗号运算符。 ECMAScript语法有意地类似于Java语法。 ECMAScript语法放松，使其成为易于使用的脚本语言。例如，变量不需要声明其类型，也不需要与属性相关联的类型，并且定义的函数在调用它们之前不需要以文字方式显示它们的声明

4.2.1对象
ECMAScript不包含适当的类，例如C ++，Smalltalk或Java中的类，而是支持构造函数，它们通过执行为对象分配存储的代码来创建对象，并通过为其属性分配初始值来初始化其全部或部分。包括构造函数在内的所有函数都是对象，但并非所有对象都是构造函数。每个构造函数都有一个Prototype属性，用于实现基于原型的继承和共享属性。通过在新表达式中使用构造函数来创建对象，例如，新的String（“A String”）创建一个新的字符串对象。调用构造函数而不使用new会导致依赖于构造函数的后果。例如，String（“A String”）产生一个原始字符串，而不是一个对象。 ECMAScript支持基于原型的继承。每个构造函数都有一个关联的原型，并且由该构造函数创建的每个对象都具有与其构造函数关联的原型（称为对象的原型）的隐式引用。此外，aprototype可能具有对其原型的非空隐含引用，依此类推;这被称为原型链。当引用对象中的属性时，该引用是指原型链中包含该名称的属性的第一个对象中该名称的属性。换句话说，首先对直接提到的对象进行检查;如果该对象包含命名的属性，则该引用引用所引用的属性;如果该对象不包含named属性，那么将检查该对象的原型;等等。在基于类的面向对象语言中，一般来说，状态由实例承载，方法由类承载，继承只是结构和行为。在ECMAScript中，状态和方法由对象承载，结构，行为和状态都被继承。所有不直接包含其原型包含共享该属性及其值的特定属性的对象。下图可以说明这个讨论：

CF是一个构造函数（也是一个对象）。通过使用新的表达式创建了五个对象：cf cf和cf。这些对象中的每个都包含名为q1和q2的属性。虚线代表隐含的原型关系;所以，比如cf的原型是CF。构造函数CF具有两个属性本身，名称为P1和P2，对CF，cf，cf，cf，cf或cf不可见。 CF中名为CFP1的属性由cf的cf，cf，cf和cf共享，CF中隐含的原型链中找不到任何未命名为q1，q2或CFP1的属性。注意CF和CF之间没有隐含的原型链接。 1 2 3，cf，cf，453pp 1 2 3 4 5 p 1 2 3 4 5 p p与基于类的对象语言不同，属性可以通过向对象分配值来即时添加。也就是说，构造函数不需要为所有或任何其属性命名或赋值。在上图中，可以通过为CF中的1 2 3 4 5 p属性分配一个新值来为cf，cf，cf，cf和cf添加一个新的共享属性。

4 .3 定义
以下是与ECMAScript相关的关键术语的非正式定义。

4 .3.1类型
类型是一组数据值。 一般来说，如果以相同类型的不同数据值代替其他数据，程序的正确运行不会受到影响。

4 .3.2原始值
原始值是Undefined，Null，Boolean，Number或String类型之一的成员。 原始值是直接在语言实现的最低级别表示的基准。

4 .3.3对象
对象是Object类型的成员。 它是一个包含原始值，对象或函数的属性的无序集合。 存储在对象属性中的函数称为方法。

4.3.4构造函数
构造函数是创建和初始化对象的函数对象。 每个构造函数都有一个关联的原型对象，用于实现继承和共享属性。

4.3.5构造函数
构造函数是创建和初始化对象的函数对象。 每个构造函数都有一个关联的原型对象，用于实现继承和共享属性。 原型原型是用于在ECMAScript中实现结构，状态和行为继承的对象。 当构造函数创建一个对象时，为了解析属性引用，该对象隐式引用构造函数的关联原型。 构造函数的关联原型可以由程序表达式constructor.prototype引用，并且添加到对象的原型的属性通过继承由共享原型的所有对象进行共享。

4.3.6本地对象
本机对象是独立于主机环境的ECMAScript实现提供的任何对象。 标准本地对象在本规范中定义。 一些本地对象是内置的; 其他可能在执行ECMAScript程序的过程中构建。

4.3.7内置对象
内置对象是由ECMAScript实现提供的任何对象，与执行ECMAScript程序开始时存在的主机环境无关。 标准内置对象在本规范中定义，ECMAScript实现可以指定和定义其他对象。 每个内置对象都是一个本地对象。

4.3.8主机对象
主机对象是主机环境提供的任何对象，用于完成ECMAScript的执行环境。 任何不是本机的对象都是主机对象。

4.3.9未定义
未定义是当变量未分配值时使用的原始值。

4.3.10未定义类型
Undefined类型只有一个值，称为undefined。

4.3.11空值
Null是表示null，空或不存在引用的原始值。

4.3.12空型
Null类型只有一个值，称为null

4.3.13布尔值
布尔值是Boolean类型的成员，并且是两个唯一值（true和false）之一。

4.3.14布尔类型
类型Boolean表示一个逻辑实体，由两个唯一的值组成。 一个称为true，另一个称为false。

4.3.15布尔对象
一个布尔对象是Object类型的成员，它是一个布尔对象的一个实例，它是一个构造函数。 也就是说，通过在新表达式中使用布尔构造函数创建一个布尔对象，提供一个布尔值作为参数。 生成的对象具有一个隐式（未命名）属性，它是布尔值。 一个布尔对象可以强制为一个布尔值。 一个布尔对象可以在布尔值预期的任何地方使用。 这是ECMAScript内置的一个便利的例子 - 在这种情况下，它适应不同背景的程序员。 那些熟悉命令式或程序性编程语言的人可能会发现数值更自然，而那些熟悉面向对象语言的人可能会发现数字对象更直观。

4 .3.16字符串值
字符串值是String类型的成员，并且是零个或多个Unicode字符的所有有序排序序列的集合。

4.3.17字符串类型
String类型是零个或多个Unicode字符的所有有限序列的集合。
4.3.18字符串对象
字符串对象是Object类型的成员，它是作为构造函数的String对象的一个实例。那是，通过在新表达式中使用String构造函数创建字符串对象，以字符串形式提供论据。生成的对象具有一个隐式（未命名）属性，它是字符串。一个字符串对象可以强制为字符串值。一个字符串对象可以在任何需要字符串值的地方使用。
4.3.19数值
数字值是Number类型的成员，是数字的直接表示形式。
4.3.20数字类型
类型号是表示数字的一组值。在ECMAScript中，精确的64位格式的IEEE 754值以及特殊的“非数字”（NaN）值，正无穷大和负无穷大。
4.3.21号码对象
数字对象是Object类型的成员，它是Number对象的一个实例，它是构造函数。也就是说，通过在新表达式中使用Number构造函数创建一个数字对象，提供一个数字论据。生成的对象具有一个隐式（未命名）属性，它是数字。数字对象可以被强制为数字值。数字对象可以在预期数字值的任意位置使用。注意a number对象可以通过将它们添加到Number原型来拥有共享属性。
4.3.22无限远
原始值Infinity表示正数无限数值。
4.3.23 NaN
原始值NaN表示IEEE标准“非数字”值的集合。

5 符号约定
5.1 句法和词汇语法
本节描述本规范中使用的无上下文语法来定义ECMAScript程序的词法和句法结构。
5.1.1 无上下文语法
无上下文的语法由多个制作组成。每个制作都有一个抽象符号，称为非终结符作为其左侧，一个或多个非终结符号和终端符号的序列作为其右侧。对于每个语法，终端符号从指定的字母表中绘出。从一个由一个独特的非终端组成的句子（称为目标符号）开始，给定的无上下文语法指定了一种语言，即（可能是无限的）可能的终端符号序列集合，这些序列可能是由于重复地替换其中非终端是左侧的生产的右侧的序列。
5.1.2 词汇语法
ECMAScript的词法语法在第7节中给出。该语法的终端符号是Unicode字符集的字符。它定义了一组生成，从目标符号Input开始，描述Unicode字符的序列如何转换为一系列输入元素。除空白和注释之外的输入元素构成ECMAScript语法语法的终端符号，称为ECMAScript令牌。这些令牌是ECMAScript语言的保留字，标识符，文字和标点符号。此外，线路终端器虽然不被认为是令牌，但也成为输入元件流的一部分，并引导自动分号插入过程（见第7.8节）。简单的空格和单行注释被简单地舍弃，不会出现在句法语法的输入元素流中。多行注释也同样被丢弃，如果它不包含行终止符;但是如果多行注释包含一个或多个行终止符，那么它将被一个单行终止符替代，该行终止符成为语法语法的输入元素流的一部分。通过将两个冒号“::”作为分隔标点来区分词法语法的产生。

5.1.3数字字符串语法

第二个语法用于将字符串转换为数值。 这个语法类似于词法语法与数字文字有关的部分，它的终端符号是Unicode字符集的字符。 该语法出现在9.3.1节。 通过将三个冒号“:::”作为标点符号来区分数字字符串语法的生成。

5.1.4句法语法

ECMAScript的语法语法在第11,12,13和14节中给出。该语法具有由词法语法定义的ECMAScript令牌作为其终端符号（见第5.1.2节）。它定义了一组生成，从目标符号程序开始，描述令牌序列如何形成语法正确的ECMAScript程序。当Unicode字符流被解析为ECMAScript程序时，首先通过重复应用词汇语法将其转换为输入元素流;这个输入元素流然后由语法语法的单个应用程序解析。如果输入元素流中的令牌不能被解析为目标非终结程序的单个实例，则程序在语法上是错误的，没有剩余令牌。句法语法的制作通过仅使用一个冒号“：”作为标点符号来区分。第11,12,13和14节所述的句法语法实际上并不完全说明哪个令牌序列被接受为正确的ECMAScript程序。还接受某些附加令牌序列，即如果在某些地方（例如在行尾字符之前）仅在分号中添加分号，则将被语法描述的令牌序列。此外，如果在某些“尴尬”的地方出现行尾字符，则语法描述的某些令牌序列不被认为是可以接受的。

5.1.5语法符号
语法和字符串语法的终端符号以及句法语法的一些终端符号，在语法的产生和贯穿本规范的每个文本直接引用这样的终端符号时，都以固定宽度字体显示。这些将出现在一个完整的程序中。非终端符号以斜体显示。非终结符的定义是由非终结符的名称引入的，后面是一个或多个冒号。 （冒号数表示生产所属的语法）。非终结式的一个或多个替代右手边随后跟随。例如，语法定义：WithStatement：with（Expression）Statement声明非终结符号表示与之相关的令牌，后面是一个左括号标记，后跟一个表达式，后跟一个右括号标记，后跟一个Statement。表达和声明的出现本身就是非终结者。作为另一个例子，语法定义：ArgumentList：AssignmentExpression ArgumentList，AssignmentExpression表示ArgumentList可以表示单个AssignmentExpression或ArgumentList，后跟逗号，后跟一个AssignmentExpression。 ArgumentList的这个定义是递归的，也就是说，它是根据自身定义的。结果是ArgumentList可以包含任何正数的参数，用逗号分隔，每个参数表达式是一个AssignmentExpression。非终止的这种递归定义是常见的。可能出现在终端或非终结点之后的下标后缀“opt”表示可选符号。包含可选符号的替代实际上指定了两个右侧，一个省略了可选元素，另一个包含它。这意味着：

```javascript
VariableDeclaration :
Identifier Initializer opt
is a convenient abbreviation for:
VariableDeclaration :
Identifier
Identifier Initializer
and that:
IterationStatement :
for ( Expression opt ; Expression opt ; Expression opt ) Statement
is a convenient abbreviation for:
IterationStatement :
for ( ; Expression opt ; Expression opt )  Statement
for ( Expression ; Expression opt ; Expression opt ) Statement
which in turn is an abbreviation for:
IterationStatement :
for ( ; ; Expression opt ) Statement
for ( ; Expression ; Expression opt ) Statement
for ( Expression ; ; Expression opt ) Statement
for ( Expression ; Expression ; Expression opt ) Statement
which in turn is an abbreviation for:
IterationStatement :
for ( ; ; ) Statement
for ( ; ; Expression ) Statement
for ( ; Expression ; ) Statement
for ( ; Expression ; Expression ) Statement
for ( Expression ; ; ) Statement
for ( Expression ; ; Expression ) Statement
for ( Expression ; Expression ; ) Statement
for ( Expression ; Expression ; Expression ) Statement
```

所以非终结迭代语句实际上有八个可选的右手边。
如果在语法语法生产的右边出现短语“[No LineTerminator here]”，那么表示生产是限制生产：如果输入中出现LineTerminator，则可能不会使用该生产在指示位置流。例如，生产：退货条款：return [no LineTerminator here]表达式opt;表示如果在返回之间的程序中发生LineTerminator，则可能不使用生产令牌和表达式。除非受限制的生产禁止LineTerminator的存在，否则会出现任何数量的事件LineTerminator可能出现在输入元素流中的任何两个连续令牌之间影响程序的句法可接受性。当“一个”一词在语法定义中跟随冒号时，它们表示每个终端以下行或行上的符号是另一种定义。例如，词法语法ECMAScript包含生产：

```javascript
ZeroToThree :: one of
0 1 2 3
which is merely a convenient abbreviation for:
ZeroToThree ::
0
1
2
3
```

当生成词汇语法或数字字符串语法的替代品似乎是一个多字符符号，它表示将组成这样的令牌的字符序列。生产的右侧可以指定使用该短语不允许某些扩展“但不是”，然后指出要排除的扩展。 例如，生产：标识符::标识符名称，但不保留字段意味着非终结标识符可以替换为可以替换的任何字符序列标识符名称只要相同的字符序列不能替代ReservedWord。最后，在这种情况下，一些罗马类型的描述性短语描述了一些非终结符号列举所有替代方案是不切实际的：SourceCharacter：任何Unicode字符

5.2算法约定

我们经常使用编号列表来指定算法中的步骤。这些算法用于阐明语义。在实践中，可能有更有效的算法可用于实现给定的特征。当一个算法作为结果产生一个值时，我们使用指令“return x”表示算法的结果是x的值，并且算法应该终止。我们使用符号结果（n）作为“步骤n的结果”的缩写。我们还使用Type（x）作为“x的类型”的缩写。数学运算，如加法，减法，否定，乘法，除法以及本节稍后定义的数学函数应该被理解为计算数学实数的精确数学结果，不包括无穷大，不包括负零与正零不同。该标准中的浮点运算模型的算法包括明确的步骤，在必要时，处理无穷大并签名为零并执行舍入。如果将数学运算或函数应用于浮点数，则应理解为应用于由该浮点数表示的精确数学值;这样一个浮点数必须是有限的，如果它是+0或-0，那么相应的数学值就是0.数学函数abs（x）产生x的绝对值，如果x是负数则为-x小于零），否则为x本身。如果x为正，则数学函数符号（x）将产生1，如果x为负，则产生-1。在x为零的情况下，本标准中不使用符号函数。符号“x模y”（y必须是有限和非零）计算与y相同符号的值k，使得对于某个整数q，abs（k）<abs（y）和x-k = q∙y。数学函数floor（x）产生不大于x的最大整数（最接近正无穷大）。请注意，floor（x）= x-（x modulo 1）。如果将算法定义为“生成运行时错误”，则终止算法（和任何调用算法）的执行，并且不返回任何结果。

6 源文本

ECMAScript源文本表示为使用Unicode版本2.0字符编码可表示的字符序列。 SourceCharacter ::任何Unicode字符但是，可以仅使用ASCII字符（相当于前128个Unicode字符）来表示每个ECMAScript程序。非ASCII Unicode字符只能在注释和字符串文字中显示。在字符串文字中，任何Unicode字符也可以表示为由六个ASCII字符组成的Unicode转义序列，即\ uplus四个十六进制数字。在注释中，作为注释的一部分，这种转义序列被有效地忽略。在字符串字面值中，Unicode转义序列对文字的字符串值贡献一个字符。请注意，ECMAScript与Java编程语言在Unicode转义序列的行为上不同。在Java程序中，如果Unicode转义序列\ u000A（例如）发生在单行注释中，则将其解释为行终止符（Unicode字符000A为换行符），因此下一个字符不属于注释。类似地，如果Unicode转义序列\ u000A出现在Java程序中的字符串文字中，则它同样被解释为行终止符，它不允许在字符串文字中 - 一个必须写入\ n而不是\ u000A来引起换行符作为字符串字面值的字符串值的一部分。在ECMAScript程序中，注释中发生的Unicode转义序列从不被解释，因此不能有助于注释的终止。类似地，在ECMAScript程序中的字符串文字中出现的Unicode转义序列总是将字符贡献给文字的字符串值，并且不会被解释为行终止符，也不会被解释为可能终止字符串文字的引号。

7词汇公约

ECMAScript程序的源文本首先被转换成一系列令牌和空格。 令牌是包含词汇单元的一系列字符。 源文本从左到右扫描，反复将最长可能的字符序列作为下一个标记。

7.1白色空间

白色空格字符用于提高源文本的可读性，并将令牌（不可分割的词汇单位）彼此分开，但不重要。 任何两个令牌之间可能会出现空格，并且可能发生在字符串中（它们被认为是形成文字字符串值的一部分的重要字符），但不能出现在任何其他类型的令牌中。 以下字符被认为是空格：

```
Syntax   WhiteSpace ::   < < < < TAB>   VT>   FF>   SP> 
```



7.2线路终端器

行终止符字符（如空格字符）用于提高源文本的可读性，并将令牌（不可分割的词汇单位）彼此分开。 与空格字符不同，行终止符对句法语法的行为有一定的影响。 通常，线路终结器可能发生在任何两个令牌之间，但是有几个地方被语法语法所禁止。 行终止符不能在任何令牌内发生，甚至不会出现在字符串中。 线路终端器也会影响自动分号插入的过程（参见第7.8.2节）。 以下字符被认为是行终止符：

```
Syntax  LineTerminator ::  <<LF>  CR>
```

7.3注释

说明注释可以是单行还是多行。 多行注释不能嵌套。 因为单行注释可以包含除LineTerminator字符之外的任何字符，并且由于令牌始终尽可能长的一般规则，单行注释始终包含从//标记到结尾的所有字符 线。 但是，该行末尾的LineTerminator不被认为是单行注释的一部分; 它被词汇语法单独识别，并成为句法语法的输入元素流的一部分。 这一点非常重要，因为这意味着单行注释的存在或不存在不影响自动分号插入的过程（参见第7.8.2节）。

```javascript
Syntax
Comment ::
MultiLineComment
SingleLineComment
MultiLineComment ::
/* MultiLineCommentChars opt */
MultiLineCommentChars ::
MultiLineNotAsteriskChar MultiLineCommentChars opt
* PostAsteriskCommentChars opt
PostAsteriskCommentChars ::
MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars opt
* PostAsteriskCommentChars opt
MultiLineNotAsteriskChar ::
SourceCharacter but not asterisk *
MultiLineNotForwardSlashOrAsteriskChar ::
SourceCharacter but not forward-slash / or asterisk *
SingleLineComment ::
// SingleLineCommentChars opt

SingleLineCommentChars ::
SingleLineCommentChar SingleLineCommentChars opt
SingleLineCommentChar ::
SourceCharacter but not LineTerminator
```



7.4令牌

语法令牌:: ReservedWord标识符标点符号

7.4.1保留字
描述
保留字不能用作标识符。
ReservedWord ::
关键词
FutureReservedWord
NullLiteral
BooleanLiteral
7.4.2关键词
以下令牌是ECMAScript关键字，不能用作ECMAScript程序中的标识符。

Syntax
Keyword :: one of

```javascript
break for new var

continue function return void

delete if this while

else in typeof with

```

7.4.3未来保留字
在提议的扩展中使用以下单词作为关键字，因此保留以允许将来采用这些扩展的可能性。

Syntax
FutureReservedWord :: one of

```javascript
case debugger export super

catch default extends switch

class do finally throw

const enum import try
```

7.5标识符
描述

标识符是无限长度的字符序列，其中序列中的每个字符必须是字母，十进制数字，下划线（_）字符或美元符号（$）字符，并且第一个字符可能不是小数 数字。 ECMAScript标识符区分大小写：标识符的字符以任何方式不同，即使仅在情况下被认为是不同的。

Syntax
Identifier ::
IdentifierName but not ReservedWord
IdentifierName ::
IdentifierLetter
IdentifierName IdentifierLetter
IdentifierName DecimalDigit
IdentifierLetter :: one of
a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z $ _
DecimalDigit :: one of
0 1 2 3 4 5 6 7 8 9

7.6标点符号

```javascript
Syntax
Punctuator :: one of
= > < == <= >=
!= , ! ~ ? :
. && || ++ -- +
- * / & | ^
% << >> >>> += -=
*= /= &= |= ^= %=
<<= >>= >>>= ( ) {
} [ ] ;
```

7.7文字
句法
文字::
NullLiteral
BooleanLiteral
NumericLiteral
字符串字面量
7.7.1零文字
句法
NullLiteral ::
空值
语义学
null文字null的值是Null类型的唯一值，即null。
7.7.2布尔文字
句法
BooleanLiteral ::
真正
假
语义学
Boolean literal true的值是布尔类型的值，即true。布尔值为false的值为布尔类型的值，即为false。
7.7.3数字文字

```
句法
NumericLiteral ::
DecimalLiteral
HexIntegerLiteral
八进制文件
DecimalLiteral ::
DecimalIntegerLiteral。 DecimalDigits opt ExponentPart opt
。 DecimalDigits ExponentPart opt
DecimalIntegerLiteral ExponentPart opt
DecimalIntegerLiteral ::
0
NonZeroDigit DecimalDigits选项
DecimalDigits ::
十进制数
DecimalDigits DecimalDigit
NonZeroDigit ::其中之一
1 2 3 4 5 6 7 8 9
ExponentPart ::
指数指标
ExponentIndicator ::其中之一
e E
SignedInteger ::
十进制数
+十进制数
- DecimalDigits
HexIntegerLiteral ::
0x HexDigit
0X HexDigit
HexIntegerLiteral HexDigit
HexDigit ::其中之一
0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
OctalIntegerLiteral ::
0 OctalDigit
八进制八进制数
OctalDigit ::其中之一
0 1 2 3 4 5 6 7
```

语义数字字面代表Number类型的值。 该值通过两个步骤确定：首先，从文字导出数学值（MV）; 第二，这个数学值被舍入，理想地使用IEEE 754 round-to-nearest模式来表示数字类型的可表示值。

一旦确定了数字文字的确切的MV，它将被四舍五入为数字类型的值。 如果MV为0，则舍入值为+0; 否则，舍入值必须是MV的数值（在8.4节定义的意义上），除非文字是DecimalLiteral，而文字具有20个有效数字，在这种情况下，数字值可能是数字 通过用0代码替换20位后的每个有效数字或通过用20字代替20位之后的每个有效数字产生的字面值的MV的数字值，然后将字面值递增到第20位而产生的字面值的值 位置。 如果一个数字不是一个ExponentPart的一部分，并且（它不是0或（左侧有一个非零数字，而在其中有一个非零数字，而不在ExponentPart中），则该数字是重要的）。

7.7.4字符串字面量
字符串字面值为零或多个以单引号或双引号括起来的字符。 每个字符可以由转义序列表示。

非终结符HexDigit和OctalDigit的定义见7.7.3节。 字符串字面值代表String类型的值。 文字的字符串值（SV）用字符串文字的各个部分贡献的字符值（CV）来描述。 作为此过程的一部分，字符串文字中的某些字符被插入具有数学值（MV），如下文或7.7.3节所述。

7.8自动分号插入

某些ECMAScript语句（空语句，变量语句，表达式语句，continueestatement，break语句和返回语句）必须以分号终止。 这样的分号可能始终显示在源文本中。 然而，为了方便起见，在某些情况下可以从源文本中省略这样的分号。 我们通过在这些情况下将分号自动插入到源代码令牌流中来描述这种情况。

7.8.1自动分号插入规则

•当程序从左到右解析时，遇到令牌（称为违规令牌），不允许任何生成语法，并且解析器当前未解析for语句的标题，则分号 如果满足以下一个或多个条件，则自动插入违规令牌：1。 至少一个LineTerminator将违规令牌与先前的令牌分开。 2。 违规令牌是}。

•当程序从左到右解析时，会遇到令牌输入流的结尾，并且解析器无法将输入令牌流解析为单个完整的ECMAScript程序，则分号将自动插入到最后的输入流。但是，对于上述规则，还有一个额外的重写条件：如果分号将被解析为空语句，则分号不会自动插入。 •当程序从左到右解析时，会遇到一些生成语法允许的令牌，但是生产是受限生产，令牌将是紧随其后的终端或非终端的第一个令牌在限制生产中（注意“这里没有LineTerminator”）），并且限制令牌与至少一个LineTerminator与上一个令牌分开，则有两种情况：1.如果解析器当前不会解析forstatement的标题，分号将在受限令牌之前自动插入。 2.如果解析器当前正在解析forstatement的头部，那就是一个语法错误。这些都是语法中限制的制作：PostfixExpression：LeftHandSideExpression [no LineTerminator here] ++ LeftHandSideExpression [no LineTerminator here] -ReturnStatement：return [no LineTerminator Here] Expressionopt;这些受限制作的实际效果如下：1.当令牌++或--is遇到解析器将其视为后缀运算符，并且至少有一个LineTerminator发生时 在前面的令牌和++或 - 令牌之间，分号在++或--token之前自动插入。 2.遇到令牌返回并在遇到下一个令牌之前遇到LineTerminator，则在令牌返回后会自动插入一个分号。 对ECMAScript程序员的实际建议是：1.后缀++或--operator应该出现在与其操作数相同的行上。 在returnstatement中的表达式应该与returntoken在同一行上开始。

7.8.2自动分号插入示例

源{1 2} 3不是ECMAScript语法中的有效句子，即使使用自动分号插入规则。 相反，源{21} 3也不是一个有效的ECMAScript句子，而是通过自动分号插入到以下变量中：{; 1 2;} 3; 这是一个有效的ECMAScript句子。 （a; b）的源不是有效的ECMAScript句子，并且不会被自动分号插入更改，因为需要分号的地方在for语句的标题中。 自动分号插入永远不会发生在报头的头部。

源返回a + b通过自动分号插入转换为以下内容：return; a + b;请注意，表达式a + bis未被视为返回语句返回的值，因为LineTerminator将其从令牌返回中分离出来。源a = b + c +通过自动分号插入变换为以下内容：a = b; + c;请注意，令牌++不会被视为应用于变量b的后缀运算符，因为LineHean +在频带++之间发生。源if（a> b）else c = d不是一个有效的ECMAScript句子，并且在elsetoken之前不会被自动分号插入所改变，即使在那一点上不会生成语法，因为自动插入的分号将被解析为空的声明。源a = b + c（d + e）.print（）不会通过自动分号插入进行转换，因为开始第二行的括号表达式可以解释为函数调用的参数列表：a = b + c （d + e）.print（）在赋值语句必须以左括号开头的情况下，程序员在前一个语句的末尾提供一个明确的分号是不错的选择，而不是依靠自动分号插入。

8 类型

一个值是一个占有九种类型之一的实体。 有六种标准类型（Undefined，Null，Boolean，String，Number和Object）和三种称为引用，列表和完成的内部类型。 引用，列表和完成类型的值仅用作表达式求值的中间结果，不能存储到对象的属性中。

8.1未定义类型

未定义类型只有一个值，称为未定义。 未分配值的任何变量都是Undefined类型

8.2空型

Null类型只有一个值，称为null。

8.3布尔类型
布尔类型表示一个逻辑实体，由两个唯一的值组成。 一个称为true，另一个称为false。

8.4字符串类型

String类型是零个或多个Unicode字符的所有有限序列的集合。 每个角色被认为占据了序列中的一个位置。 这些位置由非负整数确定。 最左边的字符（如果有的话）在位置0，位置1的下一个字符（如果有的话）等等。 字符串的长度是其中不同位置的数量。 空字符串的长度为零，因此不包含任何字符。

8.5数字类型

数字类型正好是18437736874454810627（即2 -2 +3）值，表示IEEE标准中二进制浮点算术中规定的双精度4位格式IEEE 754值，除了653 9007199254740990（即，-2-2）IEEE标准的不同“非数字”值在ECMAScript中表示为单个特殊NaN值。 （注意，NaN值由程序表达式NaN产生，假设全局定义的变量NaN没有被程序执行改变。）在一些实现中，外部代码可能能够检测各种非数字值之间的差异价值观，但这种行为是依赖于实现的;对于ECMAScript代码，所有的NaN值都是一样的。还有另外两个特殊值，称为正无穷大和负无穷大。为简洁起见，这些值也分别用符号+∞和-∞表示。 （请注意，这两个无限数值是由程序表达式+ Infinity（或简称Infinity）和-Infinity生成的，假设全局定义的变量Infinityhas没有被程序执行改变。）64 53另一个18437736874454810624（即2 -2）值称为有限数。其中一半是正数，一半是负数;对于每个有限正数，存在具有相同幅度的相应负数。注意，存在正零和负零。为简洁起见，这些值也分别用符号+0和-0表示。 （请注意，这两个零数值由程序表达式+0（或简单的0）和-0产生。）6453 18437736874454810622（即2 -2 -2）有限非零值有两种：6454 18428729675200069632（也就是2 -2）被归一化，形式为es·m·2 53 52其中s为+1或-1，m为小于2但不小于2的正整数，e为整数范围从-1074到971，包括在内。 53其余的9007199254740990（即2 -2）值是非规范化的，形式为e s·m·2 52，其中s为+1或-1，m为小于2的正整数，e为-1074。请注意，其数量不大于2的所有正和负整数可以在Number类型中表示（实际上，整数0具有两个表示，+ 0和-0）。我们说如果非零是有限数，有奇数有奇数，用于表示它的整数m（在上面所示的两种形式之一）是奇数的。否则我们说它有一个甚至有意义的。在本说明书中，短语“x的数值”，其中x表示精确的非零真实数学量（甚至可能是非理性数字，如π）表示以下列方式选择的数值。考虑Number类型的所有有限值的集合，其中-0被移除并且具有两个附加值1 024 53 971 1024（其被添加到数字类型中不能表示的值，即2 - （其为+1⋅ 2·2）和-2 53 971 1·2·2）。选择最接近x的这个集合的成员。如果集合的两个值相等，则考虑1024 1024，则选择具有均匀有效位数的值;为此，选择两个额外的值2和-2，将其替换为-∞;如果选择0，则当且仅当x小于零时将其替换为-0;任何其他选定的值不变地使用。选择1 024 1024，将其替换为+∞;如果-2有甚么意义。最后，如果2 +的结果是x的数字值。 （此过程完全符合IEEE 754“轮到最近”模式的行为。）31 31一些ECMAScript运算符仅处理范围为-2到2 -1（包括0或2）的整数，或者范围为0 32到2 - 1，包括。这些运算符接受Number类型的任何值，但是首先将每个这样的值转换为2个整数值之一。请参阅第9.5节和第9.6节中ToInt32和ToUint32运算符的说明。

8.6对象类型
对象是一个无序的属性集合。 每个属性由一个名称，一个值和一组属性组成。
8.6.1Property属性
属性可以具有以下集合中的零个或多个属性：

8.6.2内部属性和方法

内部属性和方法不会以语言显示。为了本文档的目的，我们给它们用双方括号[[]]括起来。当算法使用对象的内部属性，并且对象不实现指示的内部属性时，将生成运行时错误。暴露属性有两种访问类型：get和put，对应于检索和分配。本机ECMAScript对象具有名为[[Prototype]]的内部属性。该属性的值为null或一个对象，用于实现继承。 [[Prototype]]对象的属性作为子对象的属性公开，以获取访问权限，但不能用于put访问。下表总结了本规范使用的内部属性。描述表明他们对本机ECMAScript对象的行为。主机对象可以使用任何实现依赖的行为来实现这些内部方法，或者主机对象只能实现一些内部方法而不是其他方法。

每个对象必须实现[[Class]]属性和[[Get]]，[[Put]]，[[HasProperty]]，[[Delete]]和[DefaultValue]]方法，甚至是主机对象。 （请注意，[[DefaultValue]]方法可能对于某些[对象，简单地生成运行时错误。][[Prototype]]属性的值必须是对象或null，并且每个[[原型]]链必须具有有限的长度（即从任何对象开始，递归访问[[Prototype]]属性必须最终导致空值）。本机对象是否可以具有主机对象作为其[[Prototype]]取决于实现。该[[Class]]属性的值由本规范为每种内置对象定义。主机对象的[[Class]]属性的值可以是任何值，甚至是内置对象为其[[Class]]属性使用的值。请注意，本规范不为程序访问[[Class]]属性的值提供任何方法;它内部使用来区分不同种类的内置对象。每个本地对象按照8.6.2.1,8.6.2.2节中描述的方式实现[[Get]]，[[Put]]，[[CanPut]]，[[HasProperty]]和[[Delete] 8.6.2.3,8.6.2.4和8.6.2.5，除了Array对象的[[Put]]方法的一个稍微不同的实现（第15.4.5.1节）。主机对象可以以任何方式实现这些方法;例如，一个可能性是特定主机对象的[[Get]]和[[Put]]确实获取并存储属性值，但[[HasProperty]]总是生成false。在下面的算法描述中，假定O是本地ECMAScript对象，P是一个字符串。

8.6.2.1 [[Get]](P)

当使用属性名称P调用O的[[Get]]方法时，将执行以下步骤：
1.如果O没有名称为P的属性，请转到步骤4。
2.获取属性的值。
3.退货结果（2）。
4.如果O的[[Prototype]]为null，则返回undefined。
5.使用属性名称P调用[[原型]]的[[Get]]方法。
6.返回结果（5）。

8.6.2.2 [[Put]]（P，V）
当使用属性P和值V调用O的[[Put]]方法时，采取以下步骤：
1.用名称P调用O的[[CanPut]]方法。
2.如果Result（1）为false，返回。
3.如果O没有名称为P的属性，请转到步骤6。
4.将属性的值设置为V.属性的属性不会更改。
退货。
6.创建名称为P的属性，将其值设置为V，并给出空属性。
返回。
但是请注意，如果O是一个Array对象，它有一个更精细的[[Put]]方法（第15.4.5.1节）。
8.6.2.3 [[CanPut]]（P）
[[CanPut]]方法仅由[[Put]]方法使用。
当使用属性P调用O [[CanPut]]方法时，将执行以下步骤：
1.如果O没有名称为P的属性，请转到步骤4。
2.如果该属性具有ReadOnly属性，则返回false。
3.返回真。
4.如果O的[[Prototype]]为null，则返回true。
5.如果O的[[Prototype]]是不实现[[CanPut]]方法的主机对象，则返回false。
6.使用属性名称P调用O [[Prototype]]的[[CanPut]]方法。
7.返回结果（4）。
8.6.2.4 [[HasProperty]]（P）
当使用属性名称P调用O的[[HasProperty]]方法时，将采取以下步骤：
1.如果O具有名称为P的属性，则返回true。
2.如果O的[[Prototype]]为null，则返回false。
3.调用属性名称为[[Prototype]]的[[HasProperty]]方法。
4.退货结果（3）。
8.6.2.5 [[删除]]（P）
当使用属性名称P调用O的[[Delete]]方法时，将执行以下步骤：
1.如果O没有名称为P的属性，则返回true。
2.如果该属性具有DontDelete属性，则返回false。
3.删除名称为P的属性。
4.返回真。
8.6.2.6 [[DefaultValue]]（提示）
当使用hint String调用O [[DefaultValue]]方法时，执行以下步骤：
用参数“toString”调用对象O的[[Get]]方法。
2.如果Result（1）不是对象，请转到步骤5。
3.调用结果（1）的[[Call]]方法，其中O为此值，空参数列表。
4.如果Result（3）是原始值，返回Result（3）。
5.使用参数“valueOf”调用对象O的[[Get]]方法。
6.如果Result（5）不是对象，请转到步骤9。
7.调用结果（5）的[[Call]]方法，其中O为此值，空参数列表。
8.如果Result（7）是原始值，则返回Result（7）。
9.生成运行时错误。
当使用提示编号调用O [[DefaultValue]]方法时，将执行以下步骤：
用参数“valueOf”调用对象O的[[Get]]方法。
2.如果Result（1）不是对象，请转到步骤5。
3.调用结果（1）的[[Call]]方法，其中O为此值，空参数列表。
4.如果Result（3）是原始值，返回Result（3）。
5.用参数“toString”调用对象O的[[Get]]方法。

6.如果Result（5）不是对象，请转到步骤9。

7.调用结果（5）的[[Call]]方法，其中O为此值，空参数列表。
8.如果Result（7）是原始值，则返回Result（7）。
9.生成运行时错误。
当O的[[DefaultValue]]方法被调用时没有提示，那么它的行为就像提示是Number一样，
除非O是Date对象（参见第15.9节），在这种情况下，它的行为就像提示为String一样。

8.7参考类型

内部参考类型不是语言数据类型。本说明书仅为说明目的而定义。 ECMAScript的实现必须像在这里描述的方式产生和操作的引用一样。但是，Reference类型的值仅用作表达式求值的中间结果，不能作为变量或属性的值存储。引用类型用于解释诸如delete，typeof和赋值操作符之类的操作符的行为。例如，分配的左手操作数有望产生参考。相反，赋值操作的行为完全可以根据赋值运算符的左手操作数的句法形式的案例分析来解释，但是对于一个难题：函数调用被允许返回引用。这种可能性只是为了主机对象而被承认。本规范定义的内置ECMAScript函数不返回引用，并且没有用于用户定义函数返回引用的条款。 （不使用句法案例分析的另一个原因是它会冗长而尴尬，影响规范的许多部分。）

参考类型的另一个用途是解释函数调用的这个值的确定。
引用是对对象的属性的引用。 引用由两部分组成：基础对象和属性名称。
本规范中使用以下抽象操作来描述引用的行为：
•GetBase（V）。 返回参考V的基础对象组件。
•GetPropertyName（V）。 返回参考V的属性名称组件。
•GetValue（V）。 返回由参考V表示的属性的值。
•PutValue（V，W）。 将参考V所指示的属性的值更改为W.

8.7.1 GetBase（V）
1.如果Type（V）是Reference，返回V的基础对象组件。
2.生成运行时错误。
8.7.2 GetPropertyName（V）
1.如果Type（V）是Reference，返回V的属性名称组成部分。
2.生成运行时错误。
8.7.3 GetValue（V）
1.如果Type（V）不是Reference，返回V.
2.调用GetBase（V）。
3.如果Result（2）为空，则会生成运行时错误。
4.调用Result（2）的[[Get]]方法，传递属性名称的GetPropertyName（V）。
5.返回结果（4）。
8.7.4 PutValue（V，W）
1.如果Type（V）不是Reference，生成运行时错误。
2.调用GetBase（V）。
3.如果Result（2）为null，请转到步骤6。
4.调用Result（2）的[[Put]]方法，将属性名称的GetPropertyName（V）传递给W
值。
退货。
6.为全局对象调用[[Put]]方法，传递属性名称的GetPropertyName（V），对于
价值。
返回。

8.8列表类型

内部列表类型不是语言数据类型。 本说明书仅为说明目的而定义。 ECMAScript的实现必须像在这里描述的方式生成和操作List值一样。 但是，List类型的值仅用作表达式求值的中间结果，不能作为变量或属性的值存储。 列表类型用于解释新表达式和函数调用中参数列表（第11.2.4节）的评估。 List类型的值是简单的有序序列值。 这些序列可以是任何长度的。

8.9完成类型

内部完成类型不是语言数据类型。 本说明书仅为说明目的而定义。 ECMAScript的实现必须像在此处描述的方式生成和操作完成值时一样。 但是，“完成”类型的值仅用作语句评估的中间结果，不能作为变量或属性的值存储。 完成类型用于解释执行非本地控制转移的语句（break，continue和return）的行为。 完成类型的值具有以下形式之一：

•“正常完成”
•“V值正常完成”
•“因突破而突然完成”
•“因为断裂而V值突然完成”
•“由于继续而突然完成”
•“因为继续而在V值之后突然完成”
•“由于返回V”突然完成，其中V是一个值

任何带有值V的四种形式之一的完成称为值完成。 前两种形式之一的完成称为正常完成; 任何其他完成称为突然完成。 任何提及突击的表格的完成称为破解。 任何提交表单的完成都称为继续完成。 任何提交表单的填写都称为返回填充。

9类型转换

ECMAScript运行时系统根据需要执行自动类型转换。 为了澄清某些结构的语义，定义一组转换运算符是很有用的。 这些运营商不是语言的一部分; 它们在这里被定义为有助于语言语义的规范化。 转换运算符是多态的; 也就是说，它们可以接受任何标准类型的值，但不能使用“参考”，“列表”或“完成”（内部类型）。

9.1对主

操作符ToPrimitive获取一个Value参数和一个可选的PreferredType参数。 操作符ToPrimitive尝试将其值参数转换为非Object类型。 如果对象能够转换为多个基本类型，则可以使用可选的提示PreferredType来支持该类型。 转换如下表所示：

10 执行上下文

