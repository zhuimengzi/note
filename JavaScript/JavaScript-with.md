### JavaScript-with

先说结论。

结论就是，尽量避免用with。

这个结论不仅是我个人的，也是普遍的。可以问一下BE大神对于with的意见，估计他会告诉你，这是他最初设计上有失误之处。

ES3.1引入了strict模式，在strict模式中，with被彻底禁止。

然后说原因。

1. 性能问题

with修改了scopechain，导致标识符解析要多走一层。光光多走一层本身不是问题，在你的with中很少甚至不引用外层标识符时，可以没有损失。

但是with是**动态**修改scopechain的，这破坏了静态作用域，从而导致无法进行进一步的优化。过去的引擎都不做这方面的优化，因此你看不出性能差别，但是新的引擎会做大量优化，比如即时编译，而with导致无法做优化。

也就是说，虽然现在with并不必然慢（有些情况下甚至更快），但是将来必然慢。

当然性能取决于许多因素，with只是很小的一部分，仅仅在局部使用with，通常不会是性能瓶颈的主因。不过with还存在更严重的其他问题：

2. 隐藏bug

with破坏了静态作用域，导致可能引入隐匿的bug。
比如

```javascript
function(event){
  ...
  var x = 0, y = 0;

  with(event){
    x0 = clientX + x
    y1 = clientY + y
  }
}
```

上述代码在不同的浏览器中，由于event上支持的属性不同，而导致结果不一致。而这种隐匿的bug如果不是在初期就发现，将来会很难排查和调试。

而且这种情形理论上是无法避免的，除非你对with(obj)中的obj有完全的控制。比如在本例中，event对象就超出了你的控制，比如下一个版本的浏览器可能增加一个新属性（如IE8开始event也是native对象，一下子多出了很多属性），而恰好和你的某个局部变量同名。另一种例子是，你with了一个第三方库的对象（比如常见的with(option)，option是一个hash）。第三方库的升级如果包含了对属性的扩展，恰好和你的外层变量同名，就可能导致你的程序出现问题。

3. Object.prototype隐患

如上所说，假如with(obj)中的obj是不受控的，肯定会有问题。但是受控的呢？

比如月影说的用with来做using，其实我一度就这样做的，而且可以提供非常nice的api（如import('a')可以直接在当前scopechain上加上一个a）。
但是当我发现Object.prototype隐患之后，偶就无奈地彻底放弃了使用with来做通用namespace管理的想法。

考虑：

```javascript
function toString(x) {...}

with (myNamespace) {

    toString(x)

}
```

本意是想调用外部的toString函数，但是实际会调用Object.prototype.toString！而且你无法找到workaround，因为外部标识符总是被with优先遮蔽！除非你把Object.prototype.toString给delete掉——显然这是不可接受的。

更要命的是，任何时候，有人修改了Object.prototype，都会潜在的影响到with内部的代码。

实际上所有的with语句块都有这个问题，恶意代码可以通过修改Object.prototype来侵入内部。当然浏览器上的js安全性本身就很脆弱，也不差一个with。但是这其实说明一个问题：with(obj)中的obj本质上是不可控的。


4. with内的function的作用域

with内function声明的作用域是否受到with的影响？这是一个ES3标准语焉不详的地方。因此不同浏览器的结果是不同的。其中最离奇的是IE。

总结，如果给BE大神一次重来的机会，相信他不会这样设计with。

一个更好的with也许是这样：

类似VBScript的方式：
var x,y...
with(obj) {
  .x = x + 1
  .y = y + 1
}

这样就不会破坏静态作用域

另一方面，强类型语言中，可以静态判别对象属性，因此也可以这样：
var x0,y0...
with(obj:Point) {
  x = x0 + 1
  y = y0 + 1
}

反过来说，现在的with有这么多问题，所以with要慎用，能不用就不用了。

好吧让我们从语言的设计角度来思考一下with
with赋予JS使用者修改scopechain的能力 从性能上讲with会"影响"性能 但是究竟快慢 取决于你如何使用——所以像大多数其他语言特性一样,with对性能是中立的

with破坏了静态作用域，我们为什么需要静态作用域？JS将语言设计成动态作用域，我们的代码为什么还要为了一些不可知的优化去维护作用域的静态性？任何语言特性都可能导致相关bug，指针与内存释放，可变参数函数和溢出，运算符重载和临时对象，为了bug放弃语言特性是因噎废食。

这个Object.prototype是个问题，但最多算是一个trap。代码安全性只跟内存模型有关系，语言特性跟安全性是绝对无关的

with内function声明的作用域，虽然知道的人不多，关于这个标准倒是没什么太混淆的，只是IE实现考虑到一些旧代码，作了一些不符合标准的向下兼容。with语句中的function声明为什么是不合法的我这个我在ECMA原文中找不到依据，从词法产生式推导不出来不合法。

其实任何一个语言特性，都会带来问题，也会有额外的好处，类似的论断还有"不要在C++中使用对象","函数会影响执行效率"。在实际开发中，可能会根据团队不同的情况屏蔽一些语言特性以利于交流避免错误维持统一风格。但如果从语言全局的角度考虑，仅仅看到某些具体问题，是不能对语言特性做出评判的。

事实上，很多语言特性最后发挥的作用甚至远远超越了设计者的预期，比如C++的模板，在94年才被发现了图灵完备性。

显然，一句简单的a = b可能有四种结果，而且不到运行时你不知道会发生什么。我之前也说过，就算当下你的代码是正常的，当浏览器升级、当你引用的第三方类库升级、当别人改了一下Object.prototype……你的原本正确的程序都可能会突然不正确了……

也许有人自信满满认为以上都是不会发生的。不过不是每个人都有这样的自信，或者有这样的资格自信。神如John Resig也会偶尔犯一些基本错误，何况我们。

反正如果我是一个web开发团队的管理者，我绝不会容许任何团队成员使用with。

with带来了什么好处？只是少打几个字符而已，而这通过建立一个局部临时变量就基本可以替代了（虽然少省了2个字符）。

with的意义如果仅限于少打几个字符 当然没有任何理由使用它
我想这句话带来了我们认识的差别 正像我说过的 任何情况下不要随意对语言特性的使用方式做出定论 
然而with改变scope chain 这使得它能够一定程度上控制函数的作用域
所以从高层面上说 with是JS动态作用域的重要体现 你可以在with上找出所有动态性的优点和缺点

不论如何a = b;也不只有4种执行结果”

四种情况是指可以通过静态作用域确定的方式（也就是标识符可以指向地址，而不需要lookup——暂不考虑原型链lookup问题）。除非你外部还有with套with，否则应该就是这四种。

“我们为什么需要静态作用域？JS将语言设计成动态作用域，我们的代码为什么还要为了一些不可知的优化去维护作用域的静态性？”

1. JS并没有被设计为动态作用域。JS总体上看是静态作用域的语言，只是不纯——eval和with可以破坏静态作用域。尤其是with，本应该被设计为不会破坏静态作用域。

2. 静态作用域和动态作用域孰优孰劣，那么多年的语言发展已经给出了答案。
  譬如perl，增加了 my 关键字，就是为了取消那个鸡肋local的动态作用域的问题。
  譬如python，2.2开始加入了静态嵌套作用域。
  所有的现代函数式语言都是静态作用域。

3. 优化并非是不可知的，而是确定可知的。比如我们确切知道新的引擎会进行尾递归优化。那么我们性能关键的代码部分，就不要随随便便的递归，而是尽量写成尾递归（或者直接循环吧，嘿嘿）。

“任何语言特性都可能导致相关bug，指针与内存释放，可变参数函数和溢出，运算符重载和临时对象，为了bug放弃语言特性是因噎废食。”

简单的回答是：

并不是with导致bug，或者说，不是实现者或者使用者导致bug。with这个语言特性是设计者的bug，简而言之就是BE大人的bug。它本不应该破坏静态作用域。

通常bug不是feature，尽管托微软的福，我们常常把bug当成feature :)

还是拿js举例，typeof null == 'object' ，这纯粹就是一个bug，而绝对不是feature。用BE自己的话说，他大概是加班加昏头了，随手一写，结果遗毒10数年。

“这个Object.prototype是个问题，但最多算是一个trap。代码安全性只跟内存模型有关系，语言特性跟安全性是绝对无关的”

在我看来，Object.prototype对于with的影响是灾难性的，它直接导致本来with的失误或许可以作为某种feature（如月影所说的using）的基础都不存在了。我之前说的安全性，是指如果你使用with，则Object.prototype会成为一个入侵口。尽管在web开发中，只要不可靠的代码能运行，总是不安全的。但是这并不表示with就不存在安全性问题。举例，假设浏览器chrome是用js写的（如Mozilla FF就是如此），它对外提供了一些方法，方法内部有一些受保护的secret。这些方法被设为了writable:false，则按理，你无法修改这些方法，也无法得到闭包内部的secret。因此，从表面上看，即使允许恶意代码运行，也应该是安全的。但是，如果这些方法内使用了with，则恶意代码就有了可乘之机。

语言特性与安全性是绝对相关的。例如指针。无论是杜绝指针操作，或者至少对指针的使用加以限制，会减少大量缓冲区溢出的问题。当然不能指望一个语言特性的改善能解决所有的安全性问题，但我们绝不能倒过来说，语言特性与安全性无关。

安全性不是建立在——程序员充分知道语言特性因而总是能正确的安全的使用这些特性——这样完全不牢靠的假设上的。

如果因为你认为静态作用域比动态作用域好 就认为JS应该是静态作用域 进而认为eval和with不应该存在 那么实际上是在讨论你理想中的语言而非JS了 如果是静态作用域那么ECMA3的scope chain其实可以不用存在了

最后说代码安全性，这是个常识问题，浏览器是什么语言写的跟它如何处理JS是无关的，任何浏览器不会傻到把恶意代码跟自己的源码一起编译，然后靠语言特性保证人家访问不到自己，同样即使用JS写了浏览器，也不能跟浏览器的源码在一个context里面解释执行，然后靠scope来保证安全性。

> 其实任何一个语言特性，都会带来问题，也会有额外的好处，类似的论断还有"不要在C++中使用对象","函数会影响执行效率"。在实际开发中，可能会根据团队不同的情况屏蔽一些语言特性以利于交流避免错误维持统一风格。但如果从语言全局的角度考虑，仅仅看到某些具体问题，是不能对语言特性做出评判的。事实上，很多语言特性最后发挥的作用甚至远远超越了设计者的预期，比如C++的模板，在94年才被发现了图灵完备性。

事实上，我一度很喜欢用with，在连官方文档（如Mozilla的文档）都对with提出警告，甚至FF3.0曾将with列入deprecated warning中时，在我清楚知道with存在的先天缺陷时，我还是执着于寻找with的合理性，并且我一度认为我找到了一个非常棒的用途：namespace管理。（爱民表达过，他发现with这个可以改变scopechain的好东西时是如何的兴奋，我想我曾比他还要兴奋十倍，因为我立马以此为核心开始了一个开源项目）。然而Object.prototype的问题摧毁了我对于使用with的最后一根稻草。我不得不承认，with statement是一个彻头彻尾失败的设计。

实际上，动态作用域并非完全不可取。比如，与groovy的closure比较，groovy的closure可以设定delegate（即js的this）和owner（有一点类似scopechain），并可以设定名字解析的顺序（仅delegate、仅owner、先delegate后owner、先owner后delegate等）。这样的设计，比with这种方式更加灵活。因为js还需要一个静态的with block来包裹住，而groovy的closure可以直接以属性方式修改。这使得groovy可以做出非常漂亮的dsl。而js却很难办到（当然，费点脑筋也可以办到，不过那就要靠eval和new Function，没with什么事情了）。

Object.prototype根本不能算是with的问题 只是JS无法创建干净的对象而已 如果是像FF中允许__proto__=null 
with就不会访问到Object.prototype了 但是这是另一回事了 跟with没有任何关系

with本身是个非常自然的设计，仅仅是把一个对象加入到scope chain，如果你站在静态语言的角度分析问题，整个JS的scope chain都是不合理的，那么你要么设计一门自己喜欢的语言，要么选择其他语言，不要试图去改造JS，它的设计本身就是一个整体，只是为你提供了一种选择。

最后再说一遍，语言特性可能的用法并不仅限于你我所知的，对一个语言特性下结论说设计失败之类的是不负责任的说法。

不是我认为一个比另一个好。我只是阐述两个事实：

1. 大多数语言都是静态作用域的，或者至少是以静态作用域为主。
2. JS是以静态作用域为主的。我想，所有的JS书应该都是如此说的，奉为经典的《JS权威指南》也是如此。也可以去问BE，看看他怎么回答，呵呵。


认为语言应该以静态作用域为主，并不代表我全然排斥动态作用域。我也没有认为eval不应该存在。eval有eval的问题。但是我们现在的焦点是with的问题，不是么？事实上我从来没有认为类似with这样的特性不应该存在，而只是认为当前的with的设计是错误的。我们需要更好的with设计（像VBScript那样的，像ES4那样的），或者，像ES edition 5一样，禁用with。ES edition 5之所以还有和现在一样的with，只是为了向前兼容性。这个语言**应该的样子**，其实就是strict模式。

ECMAScript edition 5远非“我理想中的语言”，它缺少大量我认为必须的特性，比如let结构。但是如果仅就with而言，它的strict模式，也算符合我理想中的**JS语言的样子**。


顺便说说scopechain是什么东西？scopechain其实是为了实现“混杂了一点动态可能的lexical scope”而提出的一种手段。详见：[http://hax.javaeye.com/blog/273210](http://hax.javaeye.com/blog/273210)

实际上scopechain这个名字出现在标准中是过于细节繁琐了。因为scopechain本身接近于具体数据结构和算法了，而不是语言抽象。因此说scopechain可以不用存在，我很赞成。而且事实也正好如此。

在新的ECMAScript edtion 5中，令无数JSer搞不清楚的scopechain的概念终于被干掉了。

[[scope]]内部属性的解释被明确为：

A lexical environment that defines the environment in which a Function object is executed. 

而Execution Contexts这一节也完全重写了，Lexical Environment（即[[scope]]）由Environment Records组成，并明确分为declarative environment records和object environment records。

ECMA-262的规范文本一向是诘屈聱牙（不是因为语言规范本身复杂的问题，我们横向比较，js规范比java规范或者c#规范还要难以看懂），从过去到现在，我在许多有关js语言的讨论中，啃规范不知多少次，但每次去翻，还是觉得头痛不已。因为规范写得差，所以规范也产生了bug，比如：[http://hax.javaeye.com/blog/103298](http://hax.javaeye.com/blog/103298) ，此bug的官方记录：[http://bugs.ecmascript.org/ticket/145](http://bugs.ecmascript.org/ticket/145) 。

改写后的ES5规范，至少在我读来，清新易读许多了。


所以，我想，比较恰当的问题是，现在是否还应该使用with？

以我对ES edition 5的理解，strict模式其实代表了语言设计者和引擎实现者建议我们开发者使用这门语言的方式。非strict模式只是明确，为了向前兼容引擎实现者需要保证哪些特性。我更愿意把with理解为deprecated的特性。ES5给出的第一个patch是：没有with的strict模式。这也许不是最好的方式，但是是可行的方式。我们也可以继续等待着ES4（靠，应该改叫ES6？）针对with的下一个patch，看看会发生些什么。

我们在争论一个非常没必要的问题：JS是不是动态作用域
不管新规范如何设计，那已经是另一种语言，按照现有标准实现的JS是动态作用域是一个非常显然的事实
scopechain对于语言的使用者来说的确非常难以理解 
但是对实现者来说是个很清晰的事情 如果遵守标准 就一定要使用动态作用域 当然如果能找到一些等价的优化方案 可以把它部分实现为静态
我并不关心你对动态作用域和静态作用域的看法 但是JS是动态作用域这一点是必须承认的 scope chain是运行时上下文的一部分 这在所有的JS引擎中都是如此实现的 with在此基础上存在我认为合情合理

即使所有书都说JS是以静态作用域为主 但是很遗憾ECMA262现行标准和主要的JS引擎源码都告诉我 JS必须实现为动态作用域

什么叫“干净的对象”？
JS为什么要创建“干净”的对象？
我能想到的“干净的对象”的用途，实际上主要就是两个：

1. 作为hash
2. 作为插入scopechain的对象

不幸的是，js现在没法创建“干净的对象”。语言是一体的，你不能说这只是Object.prototype的问题，而不是with的问题。如果没有with和hash的用法，我们还要“干净的对象”作甚？

with是个自然的设计——没错，我同意。我事实上挺喜欢with，但是JS中的with的设计出了差错。

比方说，如果with设计成vbscript那样，那没有任何问题。或者有了“干净的对象”，那也ok。又或者，with被限定为只能访问enumerable的那些属性，也没问题。

不幸的是，with恰恰长成了现在这个样子。

这与我是否站在“静态语言”的角度分析问题毫无关系。实际上“静态语言”和“静态作用域”是两码事情。就算“静态作用域”，我已经说过，我并不排斥“动态作用域”，我喜欢groovy的动态作用域设计，但是我排斥设计**错误**的“动态作用域”。或者说，我排斥设计错误的“语言特性”。他们名为特性，实际是bug。

scopechain是个精巧的设计，它并没有不合理，不合理的是按照**现在的方式**用scopechain去实现with。

我们还能举出许多JS中因此造成的**错误设计**

比如，按照规范（我指老的ES3），catch(e)这个e也是在scopechain上加入了一个object={e:error}，按照规范，(function f(){})，这个f也是在scopechain上加入了一个object={f:func}。而这统统都是**错误的设计**，因为它会引入之前描述的Object.prototype污染问题。

实际上，引擎在这里表现不一，对于catch，Spidermonkey和JScript就都没有按照规范做，但是实际上，他们虽然不合规范，但做法是正确的。spidermonkey的函数表达式内部曾经存在Object.prototype污染问题，后来修正了。V8曾经在某个上面有问题（具体哪个我忘记了），但是现在修复了。


根本原因是，写规范的人当时忘记这档子事情了！！！而with也是如此而已！！！


我在这里说with是个设计失败，绝不是不负责任，而只是就事论事。

with 的 Object.prototype 污染问题，只是因为写规范的人忘记了 Object.prototype 可能造成这个问题，而不是有意为之。所以它是bug，不是特性。


再如之前所举的joined function例子，只是当时写规范的人忘记了function不是immutable的，所以犯错了。

JS是好语言，我喜欢，但是不代表我要连它的错误也一起喜欢（这不是讨老婆好不好）。

总之，语言特性是有好坏的。之所以JS暴露出那么多严重问题，是有许多历史原因造成的。

只是从你的角度看是个错误而已 
用静态语言的眼光去看JS才会造成问题 JS所有的标识符本来就是属性访问  with中的代码能访问到Object.prototype也没什么好奇怪
语言特性合不合理不是你随便一说 因为能访问到Object.prototype就是设计不合理了

C++模板元编程受到很多人的痛恨 boost和stl照样是高效和设计的典范
有了scope chain， with就必然是个合理的操作 有问题也与with无关

ES3现行规范确实有不少问题 catch里面访问得到Object.prototype才叫真的bug（这个我也发过，[http://bbs.51js.com/viewthread.p ... highlight=%2Bwinter](http://bbs.51js.com/viewthread.php?tid=79018&highlight=%2Bwinter)） 但是with显然不是其中之一

如果说之前的ES4和ES3相比是不是一种新语言，那有争论。但是ECMAScript edtion 5（即ES3.1），那当然不是另外一种语言，ECMAScript edition 5是从当前我们在用的各种JavaScript实现总结出来的标准。它仍然是ES3，是修订了错误的ES3。如果你认为这是一种新的语言，那新语言也太多了。

JS是动态作用域是个非常非常**不显然**的**事实**（其实不是事实）。除了我们这帮子每天要跟js搏斗的人，你问问一般程序员的看法，他们会认为JS是动态作用域而不是词法作用域吗？（当然前提是这些程序员知道什么叫动态作用域，而不会把动态作用域和动态语言混淆起来——我有点怀疑这一点，因为现在使用动态作用域语言的程序员太少了）。

实际上JS也不是“动态作用域”，或者说不符合一般“动态作用域”的定义（参见：[http://en.wikipedia.org/wiki/Scope_](http://en.wikipedia.org/wiki/Scope_)(programming)#Dynamic_scoping）。

最本质的问题：你能声明一个变量是动态作用域的吗（像perl的local那样）？

不行！因为JS根本没有设计为要提供动态作用域。

with所导致的动态作用域的效果，只是一个以scopechain来实现所造成的副作用而已。with本身的用意（提供shortcut）与动态作用域风牛马不相及。

with不合情也不合理，理由之前都说过了。with（至少Object.prototype污染这一点）就是一个历史造成的错误，就像ES3标准中的其他种种错误一样。

唉 真是无语了 JS所有的变量都是运行时访问 怎么就不是动态作用域了呢 难道非要跟perl语法一样才叫动态作用域？JS的scope chain跟wiki里面描述的模型明显是等价的。

归根结底还是 "with本身的用意(提供shortcut)" 这种思想在作怪

> scopechain和with没有关系。不用scopechain上加东西，一样可以实现with，正如不用scopechain，一样可以实现catch和(function f)。所以scopechain的合理不能推导出with的合理。

跟你说的恰恰相反 with只是个往scopechain上加东西的操作 没有任何别的意义 你想提供shortcut 当然可以有别的实现 如果你认为往scopechain上加个对象是不合理的话 好吧我没什么可说的

为了争论而争论没什么意思 so 此帖我到此为止 该说明白的都说明白了 大家可以客观判断

要区分**目的**和**效果**。如果你不加以区分，自然会得出JS是动态作用域。但是这个动态作用域只是效果，不是目的。

scopechain的目的是为了实现带有with和eval特例的lexical scope而不是dynamic scope。