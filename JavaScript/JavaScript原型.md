### javascript原型

因为JS是弱类型的，所以变量没有类型，只有数据有类型。

JS代码复用性比其它语言弱太多。比如，你甚至无法为一组对象做一个统一的操作，必须通过循环遍历来实现，于是JS引入了原型（prototype）,具体的实现方式是为每个对象规定一个私有属性[[prototype]]，当读取一个对象的属性时，如果对象本身没有这个属性，会尝试访问[[prototype]]的相应属性。具体实现中，[[prototype]]所指向的对象仍然可以有[[prototype]]，实际的访问就是一个链式的操作，直到找到这个属性或者[[prototype]]为空为止，所以常常听到[[prototype]]链的说法。为了防止[[prototype]]出现循环，JS引擎会在任何对象的[[prototype]]属性被修改时检查。

在JS中，函数仅仅是一种特殊的对象，JS设计了()运算符和function关键字让JS的函数看起来更像是传统的语言。只要实现了私有方法[[call]]的对象都被认为是函数对象(这个[[call]]跟大家比较熟悉的Function.prototype.call完全是两回事)，类似[[prototype]]，[[call]]也是语言使用者完全无法访问的，这一次FF也没有为我们提供公有属性来替代。

JS为了让自己的语法看起来更像是Java之类的语言，又引入了new关键字，在上面大部分语言中new都是针对类来做的，而JS没有类，甚至没有声明域，所以这个new还是要在对象上做文章，new会调用私有方法[[contruct]]，任何实现了[[construct]]的对象都可以被new接受。然而如何才能让一个对象可以被new呢？JS并没有额外提供构造这种对象方法，所以所有通过function关键字构造的函数对象被设计成实现了[[construct]]方法。这也就是JS的new很奇怪地针对函数的原因。值得一提的是，并非只有函数可以被new,JS的宿主环境可能提供一些其它对象，典型的例子是IE中的ActiveXObject。

所有函数的[[construct]]方法都是类似的：创建一个新的对象，将它的[[prototype]]设为函数对象的共有属性prototype，以新对象做为this指针的值，执行函数对象。

任何时刻都不要忘记原型模式的意图：指定种类，创建对象。

判断一段代码是否在使用原型模式的一个重要标志就是复制之后引用它的目标变量类型是否是抽象类型。

P r o t o t y p e的主要缺陷是每一个P r o t o t y p e的子类都必须实现C l o n e操作，这可能很困难。例如，当所考虑的类已经存在时就难以新增C l o n e操作。当内部包括一些不支持拷贝或有循环引用的对象时，实现克隆可能也会很困难的。