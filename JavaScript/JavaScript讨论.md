### JavaScript讨论

每种语言都有他的特性

js也是的， 强化类型是有好处的， 像js的null和object， 判断是否是一个html对象， 就感觉的力不从心了，可能我无知吧，

比如我们判断一个变量或者对象属于什么类型的， 还需要typeof 或者instanceof这些在C++当中根本就不存在要判断，直接的编译不通过

所以问题就在这里了 强类型语言有C++已经足够了
算得上成功的改进最多到C#/Java 已经不需要更多类似的语言了

现在的问题不是强类型好不好，而是JS为什么要强类型。

ES3（就是现在的JS）也混合了大量的语言特性，但一直受到好评，为什么？因为它基于一个非常小的语法规则集合实现了这些特性，整个语言建立在非常简洁的逻辑之上。但到了ES4，却靠各种复杂的关键字和新的语法结构来实现更多特性，而且很多地方让人感觉不伦不类。

就像前面说的，现在到了其他语言模仿Js的时候了，C#、JAVA的新版本开始关注动态带来的好处，并且在其中加入了closure、匿名函数、匿名对象、默认类型声明之类的语法。但ES4这样做的结果就是让JS本身的优美丧失，反过来变成一个拙劣的模仿者。

JavaScript 主要的问题到不是不支持多重继承，熟悉 C++ 的朋友都知道，多重继承是一只双刃剑，用的不好也会伤了自己。 
JavaScript 的设计主要参考了 Java 和 Perl 两种语言。其实 JavaScirpt 这门语言本身的设计是非常精巧的，结合了 Java 和 Perl 的很多优点，语言本身的设计即使拿到今天也不落伍。和 Python 一样，JavaScript 中函数和类是合一的，这样的设计带来了很多的好处。 
JavaScript 最初是为了编写一些比较简单的页面脚本而设计的，并没有考虑到大规模组件化开发的需求，对于面向对象编程的支持是很不够的。突出表现在以下两个方面： 
1、JavaScript 不支持 package 或者 namespace 的概念，所有的函数名称都是全局名称，因此在大规模开发时容易造成重名。 
2、JavaScript 中的继承并不是真正的继承，而是所有的子类对象共享同一个父类对象。这个父类对象相当于一个 Singleton，一般不应该有自己的属性。如果某个子类对象修改了父类对象的属性，就会影响到所有的子类对象。正是因为这个限制，JavaScript 很难实现 3 层以上的继承，因此无法构建大型的面向对象继承体系（当然，那位说了，为什么要用继承，全部用组合难道还有解决不了的问题么？）。 

上面两个是最主要的问题，这两个问题限制了基于 JavaScript 的大规模组件化开发。不过考虑到目前客户端 Ajax 组件库的规模相对于服务器端 Java 组件库的规模来说要小的多，JavaScript 目前的能力基本上够用了。 

第二个问题来源于基于原型的继承。其实整个计算机工业界对于基于原型的继承应该怎样并没有很好的想法，幸好原型比类更轻量级，可以非常简单的修改以避开继承的问题。甚至完全不用继承，因为基于原型的OO提供了对象property的增删，同一个类型的对象可以拥有完全不同的属性。 

#### 重载

\>    或许这个是OOP编程中比较复杂的地方了，在Javascript的实现中有点无奈，也就是通过prototype的方式来完成的，不过因为我不清楚如何调用父类的实现函数，那么在重载中只能够重新编写所有的实现了，另外就是在实现中实例化一个父类，然后通过调用它来返回需要的东西。

这个无奈只是作者杞人忧天 :)
实例化一个父类对象没有什么大不了的，不要拘泥于“正统”的OO观念。想想看，在原型继承的时候，你实际上不正是实例化一个父类对象，然后赋值给prototype吗？只是这个并不是一个真正需要的实例，而只是一个“模子”，所以也许你可以不用传给构造函数任何参数。调用“父类”的方法，也并不必然需要实例化一个父类对象。回忆一下调用父类构造函数的过程。在调用之后，你就已经获得了所有的通过父类构造函数初始化的属性和方法。要干什么随便你了。

#### 关于Object是不是第一型的问题



第一、js的保留字不能说明问题，因为保留字只是保留字。function是而object不是，完全是因为语法需要。其实许多人包括js的发明者Brendan Eich都说过js的保留字过于严格，有许多字没有必要列入。归根到底是当初的非技术原因，即netscape当时决定完全使用java语法，尽管js更像lisp和self。所以有许多现在没用将来也不会用的关键字因为是java的关键字所以也被列为了js的关键字。

第二、function是语法的组成部分，所以不能修改。这可以理解。class是关键字并不说明java或c#的class就是第一类对象。至于你说Object可以重定义，我想你是说可以修改Object.prototype？还是说你写了一个新方法叫做Object？

第三、由于实现的问题，确实存在许多没有在spec中解释的东西，况且ecma规范本身也是催熟的，有一些问题。function的位置确实非常特殊。例如一个继承Function的类的实例typeof的结果却是object而不是function（这里使用继承的术语相信你理解我的意思），只有用function构造和function表达式或者new Function出来的其typeof才是function。但是同样的情况并非Function独有，Array也有类似的问题，即[]的访问方式是不能被继承的（所以一般而言最好不要写Array和Function的子类，因为行为不能一致）。

第四、第一型本身是个理论术语，我认为简单的来说，就是可否被当作参数传递和作为函数调用的返回。所以对一切皆对象的js来说，从来没有听说过object不是第一型的说法。放在js这样具体的语境下，由于涉及一些ecma spec和具体implemention的问题，才造成一些奇怪的东西。例如可能存在typeof结果为function而instanceof Function为false的情况，另外ie的xml dom上的所有方法的typeof结果为object而不是function。甚至js本身有个设计失误：typeof null居然等于object，呵呵。

我还没有看到你重新声明Object，但是我觉得Object作为重要的核心，最好不要去动它。例如有一些script给Object.prototype增加了一些东西，就被批评为影响了for in的惯用法（虽然按照道理说，应该使用一个真正的map而不是用for in惯用法）。

关于分开声明和实现的问题。是这样，由于js并不是编译语言，所以所谓声明完全是一个使用惯例。例如使用 

```javascript
xxx.prototype = {
  f1 : function() { ... }, 
  f2 : function() { ... }, 
  p1 : 'a property', 
  f3 : function() { throw 'f3 is a '}
}
```



另外，就是用递归（函数调函数）来实现循环。考虑到递归函数调用中会导致栈溢出(Stack overflow at ...)，
所以函数式语言就提出了“尾递归”，也就是在书写代码是“确保”仅只在函数内的最后一个运算中递归调用。
这样一来，这个递归调用就不需要保留栈了——因为再没有后续运算了，因此就能被优化成一行不需要返回的
jmp汇编指令。

### 

1. 对象(Object)在JavaScript中不是第一型的”这个话显然错误。function在js中确实是first-class的。但如果因为构造函数也是function，就认定js中Object不是first-class的，可真是荒谬了。 
2. 虽然尚未看到后文，但js不存在“析构”是基本常识。js也是采用自动垃圾回收的。
3. 判断undefined，应该使用 v === undefined ，而不是 == 。因为null == undefined的结果也是true。姑且认为作者是笔误吧，否则这个错误也太大。
4. string上的那些html相关方法不是js标准所规定的，只是为了兼容早期的js而保留的。有些js实现并没有这些方法，现在也不应该再使用这些方法。 
5. js也可以声明和实现分开。当然不是语言强制的，但是你确实可以这样做。后续文章的虽然没有看到文字，但js中没有反射的说法，因为js是基于prototype的全动态的脚本语言，，当然你可以与static语言的reflection进行比较，但不宜把js中对应的能力称作reflection。

关于“Functions在JavaScript中是第一型的”，这样的说法我最先自一份Douglas Crockford的文档(http://www.crockford.com/javascript/javascript.html)，你可以读到它的中文版本。至于说“Object不是第一型”，这一点我一直也在思考它对不对。我之所以说它不是，是因为在JScript的保留字列表里面，可以查到object不是保留字，而function是。你甚至会发现class是关键字，但objet不是。接下来，你可以发现，Object()作为类型，是可以被重定义的，而function()不可以。也就是说“function可以重新实现Object”。——这已经不是“function是不是用作构造函数”那么简单了。 

Object能被重新声明的问题，我原本是打算在讲Romo的内核实现的时候再论及的。因为那也是Romo内核中很特殊的一部分。 

关于析构。我只是说要讨论JavaScript中的析构问题，并没有说JavaScript有析构的机制。事实上，有些代码中，是要涉及到“什么时候会释放JavaScript对象”这样的问题的。 

关于&quot;v === undefined &quot;。很感谢你指出来。这的确是我不知道，而不是笔误。错了就是错了，这个我得承认。 

关于字符串中类似于&quot;fontcolor&quot;的这些一些方法，我也不推荐使用。我在正文里也说过了，最初出现它们的原因，是因为了适应“浏览器实现的超文本环境”。但我的确没注意到他不是ECMA规范中的内容。——当然，Netscape对Client JavaScpipt的规范中一直是有它们的。

我想我在行文中总是少了一些与ECMA对照的部分。

首先，我没想出来如何在js中把声明和实现分开。 

关于反射的问题，我在使用这个名词之前，特地翻阅了一些书籍，关于反射的定义是这样“审查对象的成员及其类型信息的能力”。因此我认为“反射”是可以准确地描述for .. in的特性的。——尽管js中的确没有这样的说法。 至于“动态”与“静态”语言的问题，我不明白的是，难道C#或者JScript .NET就是一种“静态”的语言？

JavaScript中的String类型原本没有什么特殊的，但是JavaScript为了适应
“浏览器实现的超文本环境”，因此它具有一些奇怪的方法。例如：
  link() : 把一个有HREF属性的超链接标签<A>放在String对象中的文本两端。
  big()  : 把一对<big>标签放在String对象中的文本两端。

一个常常被开发者忽略的事实是：JavaScript本身是没有事件(Event)系统的。通
常我们在JavaScript用到的onclick等事件，其实是IE的DOM模型提供的。从更内核
的角度上讲：IE通过COM的接口属性公布了一组事件接口给DOM。

有两个原因，使得在JS中不能很好的识别“一个属性是不是事件”：

- COM接口中本身只有方法，属性与事件，都是通过一组get/set方法来公布的。
- JavaScript中，本身并没有独立的“事件”机制。

因此我们看到event的识别方法，是检测属性名是否是以'on'字符串开头(以'On'开
头的是Qomo的约定)。接下来，由于DOM对象中的事件是可以不指定处理函数的，这
种情况下事件句柄为null值(Qomo采用相同的约定)；在另外的一些情况下，用户可
能象obj2这样，定义一个值为 undefined的事件。因此“事件”的判定条件被处理
成一个复杂的表达式：
   ("属性以on/On开头" && ("值为null/undefined" || "类型为function"))

另外，从上面的这段代码的运行结果来看。对DOM对象使用for..in，是不能列举出
对象方法来的。

JavaScript中不明确区分函数与方法。

补充一点，再来挑点刺，呵呵。

1. 在用for..in时，可以配合hasOwnProperty，ie和moz都支持。 
2. 使用on开头的方式约定不是很好，w3c dom event模型就不用on。
3. 我不认为event必须是oop的一部分，过多使用event会造成问题，比如很难发现的死循环调用。event上手容易，所以更容易中下隐患。还有是调试问题。我用过一段时间.NET 1.1，在eventHandler中的异常经常无法跟踪。c#加上的event的语法糖衣，在我看来至少在1.1还是很简陋，很多时候我宁可使用匿名类。顺便说一下，熟悉了w3c dom event的设计，再用winform的event，真是不舒服，而且msdn这一部分的文档也很糟糕。也许.net 2.0提高了很多，不过我恐怕没有机会再用它了，呵呵。 
4. “如果一个函数被作为普通函数(而不是对象方法)调用，那么在函数中的this关键字将指向window对象。与此相同的，如果this关键字不在任何函数中，那么他也指向window对象。”最好严格说明一下，这个this指向的是host或者说global对象。在browser环境下是window。在其他js环境就不是了。……这个前面已经有人说过了。 
5. “需要注意的是，此时的foo()仍旧是一个普通函数调用，而不是对象方法调用。”这个话有点奇怪。使用call和apply是等价于对象方法调用的（除了moz有个不合ecma spec的副作用：https://bugzilla.mozilla.org/show_bug.cgi?id=314874）。不知道你有什么必要刻意区分它？对于被调用的foo来说并不能区分是通过何种方式调用的（除了检测caller）。
6. “只能限定对obj的既有属性的读取，而不能主动的声明它” .我最初用js的时候老返这个错误，呵呵。btw，应该指出with本身是有问题的，在一些情况下有二义性。此外with会降低性能。实践的角度来说，不应该在代码中使用with语法。 
7. in的最大问题是，IE5.0不支持。而且它是一个语法构造，所以如果要兼容IE 5，就不能使用in。只能用这样： if (x in y) 改写成 if (typeof y[x] != &quot;undefined&quot;)。 关于查找数组中的元素，moz增加了indexOf的方法。 “另外，arrayToObject()也存在一些开销，这使得它不适合于频繁变动的查找集。最后，(我想你可能已经注意到了)使用对象来查找的时候并不能准确定位到查找数据，而数组中可以指向结果的下标。” 变动的时候就处理变动的部分好了。 查找下标么，如果数组是不变的，可以把obj[arr[i]]=null改为obj[arr[i]]=i。反正就是个map。 另外，应该注意到你现在的代码可能会覆盖valueOf,toString等，如果这点比较重要的话，应该把key预先变换一下

事件”是一个“如何驱动编程模型”的机制／问题，而不是语言本身的问题。

null是关键字；undefined是Global对象的一个属性。

关于__proto__属性，我以前是知道的，但不是从ECMA里，而是从一些其它的framework的实现代码中。我撰写这些文章时，主要的参考资料是源代码和一些自己编写的测试代码。一方面，我的英文不够好，若非必须，我不会去啃Ｅ文的资料；另一方面，我主要的研究对象是IE中的JScript，它对ECMA的实现并不完整。——正好，你提到的__proto__是JScript对ECMA实现的不完整的地方之一。

所以尽管以前看到过__proto__，也没有注意。 但是还是很感谢你提到“对象”对__proto__中属性的读/写方式。——由于JScript不公布__proto__，所以我一直以为在JScript中没有访问原型实例的方式。因而认为JScript是存储一个复制的备份，而不是prototype的一个引用。——我在前面讲到过“函数有原型(prototype)属性，但对象没有”，就是这个缘故。

从你的描述来看，使用写复制的技术，将是更佳的方案。为此，(在发这篇回贴之前，)我又阅读了FireFox的源代码中对JS的实现部分，以及通过mono的源代码查读了.NET框架中对JScript 7+的实现部分，的确如你所说：是采用原型引用，而非原型复制的技术实现。

由于不能阅读到有关IE中JScript.dll的有关代码(事实上我也没有精力去反编译再读汇编)，在对可能的实现技术经过一番考量之后，我认为JScript采用你所提到的方案来实现更为合理。——说明一点，正如JScript没有完全实现ECMA一样，我也不确定它会按ECMA的推荐方式来实现原型继承。因为“复制”与“引用”的实现结果，在用户代码一级，是感觉不到的。

但是，你的确解决了我的一个疑惑，一直以来的疑惑。所有关于js的原型继承的文章中，都会提到“过深层次的继承，会导致属性存取的效率降低”。如果按照我上面所说的“原型是复制的”，那么就不会有这样的问题；而按照你所说的“对象执有原型的引用”，那么这个描述就无疑是正确的了。 

从这个角度分析，我们可以看到“采用原型复制”的方式，是以存储换效率的方案；而“采用原型引用”是以效率换存储的方案。——很明显，脚本语言的设计之初不会考虑用户会在上面实现过深的继承层次，因此以“原型引用”的方式会更有效。 

同理，Delphi一类的高级语言，则与此相反，采用了复制实例来实现，这样在较深的继承层次中，属性的存取仍有很高的效率。——当然，正因为我存在这样的认识，才会使你觉得我“在用Class-base的思维思考Prototype-Base问题”。 

再次感谢你指出这个问题。这使我对prototype相关的问题有了新的认识，可能也会因此在正式公布Qomo的代码时，修改一些设计和实现的代码。 