### JavaScript-function

1.函数对象和函数指针
函数实际上是一个可执行的对象，任何访问函数对象的方式都是函数指针。
不论 使用哪一种方式
var a=new Function(...);
function a(...){...}
var a=function(...){...}
得到的函数名a都是一个指向函数的指针 可以用var b=a;来创建另外一个指向它的指针。
但是 它们指向同一段函数。因为函数名是一个指针，所以能够被作为参数传递。
()运算符作用于一个函数指针将会执行它所在的函数，当然还会传入参数。


2.函数直接量(函数文字量)
实际上函数直接量这个说法并不准确 但可以通俗地解释一些用法
125 "good"是都是直接量 可以在代码中不通过变量名使用 函数也有类似的用法
function(){...} 代表了一个函数指针的值 它指向function(){...}定义的函数
那么 (function(){...})() 就执行了这个函数 a=function(){...}就创建了这个指针的一个副本

3.函数对象的成员 
函数对象继承自object对象 它还有自己的属性和方法
查到的就这么多 来自vs2005的提示
f.apply(thisValue,argArray);//在thisValue对象上执行 参数由数组argArray提供
f.call(thisValue);//在thisValue对象上执行，不是没有参数，要用参数的话直接跟在thisValue后面
f.prototype; //原型 很常见 前面也用过 不多说了。 
f.length;//参数列表的长度

f.hasOwnProperty(propertyName);//继承自Object的方法，检查对象是否有指定属性
f.propertyIsEnumerable(propertyName);//继承自Object的方法，检查指定属性是否能被for in枚举出来 （除了firefox下的prototype 其他属性都不能被枚举）
f.toLocaleString();//继承自Object的方法，转换为字符串
f.toString();//继承自Object的方法，转换为字符串 在alert document.write等时自动调用
f.valueOf();//继承自Object的方法，求值，对象做算术运算时自动调用，如果默认就是toString 

3.javascript函数能访问的范围
javascript函数究竟能访问那些资源？ 包括三部分：函数的作用域、this指针、参数除此之外函数无法访问任何资源。
如果要比较清晰地理解函数 应当想像函数有三组参数：
第一组是作用域 在定义时确定 是函数定义位置决定的 暂称为外作用域 在函数定义处可以访问的变量和函数在函数中也可以访问，不论调用这个函数的指针被传递到哪里
第二组是this 在函数被调用时确定 
  如果函数是用()调用的  它默认指向函数所属的对象：如果函数是某个对象的成员 那么this指向这个对象，否则指向全局对象（大多数时候是window）
  如果函数是用apply或者call调用的 this指向指定的thisvalue
第三组是参数 在函数被调用时确定 在参数列表中的参数可以直接访问 不再参数列表中的参数可以用arguments访问

4.函数作用域的生成与访问
函数除了能够访问一个作用域之外 每次执行 会生成一个新的作用域 （闭包）
此作用域之外的代码无法访问这一作用域的变量 此作用域内的代码可以访问这个作用域以及此函数定义时的作用域。

跨作用域的访问只能通过指针。js中object是指针类型。
想要获得指向某个作用域的指针 必须从这个作用域中把指针传递出来：即把此作用域中的指针类型变量的值赋给其他作用域的变量
前面所说一个函数中能够访问的资源包括 this 外作用域 参数 所以可以通过这种方式访问其他作用域中的变量。
一个很bt的例子

```javascript
//想办法访问一个很深的嵌套中的函数对象
var o=new Object();
function a(obj){
    var pointer;
    (function(){
        var p=new function(){
            function f(){
                var x=function(){alert("Try to visit me!")};//x是一个指针                         
                return x;//作为返回值传递出第一层;            
            }
            this.x=f();//用this传递出第二层;
        }
        pointer=p.x;//用外作用域传递出第三层
     })()
     obj.x=pointer;//用参数传递出第四层
}
a(o);
o.x();
```

最后这个例子太BT了，实际上，虽然js的function有这样的能力，但是在使用时我们一般会有一个限制，就是闭包中访问闭包外变量时，不应当采用有“副作用”的表达式，例如++、--或者赋值，也就是说限制闭包访问外部域的内容仅限于“读”和“表达式计算”，可以修改外部变量实际引用的对象的值，但是不要在闭包内修改外部变量本身的值。所以下面的例子

```javascript
function c(a){
    return function(x)
    {
        return x+a++;
    }
}
```

通常是合法但不合理的，因为这是一个有副作用的闭包。在程序逻辑复杂的情况下这很容易导致混乱。因为这个闭包在什么时候调用是完全不确定的。这个闭包的存在使得这个函数每次调用的返回值完全不同，即使采用的是同一个参数。这显然违背了functional“公式化”的基本原则。

不过，实际上上面这种函数倒有一个特殊用途，用来生成某些特殊的计数器 :)
所以限制也不是绝对的...